---
vars:
  compose_base_file: infra/compose/docker-compose.yml
  compose_debug_file: infra/compose/docker-compose.debug.yml
  compose_kafka_file: infra/compose/docker-compose.kafka.yml
  compose_rabbitmq_file: infra/compose/docker-compose.rabbitmq.yml
  compose_aws_file: infra/compose/docker-compose.aws.yml
  compose_nats_file: infra/compose/docker-compose.nats.yml
  compose_http_file: infra/compose/docker-compose.http.yml
  compose_io_file: infra/compose/docker-compose.io.yml
  env_dir: infra/env
  env_example_dir: infra/env/example
  proto_dir: proto
  src_dir: src
  golang_image: golang:1.25.4
  redocly_cli_image: redocly/cli:2.11.1
  asyncapi_cli_image: asyncapi/cli:2.16.0
  modelina_cli_version: "latest"
  yq_image: mikefarah/yq:4
  buf_image: bufbuild/buf:1.60.0
  scc_image: ghcr.io/lhoupert/scc:v0.0.2
  trivy_image: aquasec/trivy:0.58.0
  syft_image: anchore/syft:v1.18.1
  grype_image: anchore/grype:v0.86.1
  trufflehog_image: trufflesecurity/trufflehog:latest
  hadolint_image: hadolint/hadolint:v2.12.0-alpine
  actionlint_image: rhysd/actionlint:1.7.7
  gosec_image: securego/gosec:2.22.0

version: 3

dotenv:
  - ./infra/env/app.env

tasks:
  default:
    desc: "List available tasks with their summaries"
    summary: |
      Shows the curated list of project automations so you can quickly discover useful entry points.
    cmds:
      - task --summary
    silent: true

  gen-env-files:
    desc: "Generate .env files from the example templates"
    summary: |
      Copies the example environment files into {{.env_dir}} so local tooling and compose stacks have the expected configuration.
    cmds:
      - echo "Preparing environment configuration in {{.env_dir}}"
      - mkdir -p {{.env_dir}}
      - |
        for file in {{.env_example_dir}}/*.example; do
          cp "$file" "{{.env_dir}}/$(basename "${file%.example}")"
        done

  ci:
    desc: "Run the full GitHub Actions workflow locally"
    summary: |
      Uses nektos/act to execute every job defined in the repository workflows for a quick pre-flight CI check.
      Includes security scanning with Trivy.
    deps:
      - scan-security
    cmds:
      - echo "Running all GitHub Actions locally via act"
      - act | grep -v '::'

  scan-security:
    desc: "Run Trivy security scan on the codebase"
    summary: |
      Scans the codebase for vulnerabilities in dependencies and misconfigurations in IaC files using Trivy.
    cmds:
      - echo "Running Trivy filesystem vulnerability scan..."
      - |
        docker run --rm -v "$(pwd):/workspace" -w /workspace {{.trivy_image}} fs \
          --severity CRITICAL,HIGH \
          --exit-code 1 \
          --ignore-unfixed \
          --scanners vuln,secret \
          .
      - echo "Running Trivy config scan for IaC misconfigurations..."
      - |
        docker run --rm -v "$(pwd):/workspace" -w /workspace {{.trivy_image}} config \
          --severity CRITICAL,HIGH \
          --exit-code 1 \
          .

  test-go:
    desc: "Run Go tests with coverage"
    deps:
      - gen-buf
    summary: |
      Runs all Go tests with race detection and generates a coverage report.
    cmds:
      - |
        set -euo pipefail
        echo "Running Go tests with coverage under {{.src_dir}}"
        docker run --rm -v "$(pwd)/{{.src_dir}}:/workspace" -w /workspace {{.golang_image}} bash -c '
          set -euo pipefail
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
          echo ""
          echo "=== Coverage Summary ==="
          go tool cover -func=coverage.out | tail -1
        '

  test-go-local:
    desc: "Run Go tests locally (without Docker)"
    summary: |
      Runs all Go tests locally with race detection and coverage.
    cmds:
      - |
        set -euo pipefail
        echo "Running Go tests locally under {{.src_dir}}"
        cd {{.src_dir}}
        go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
        echo ""
        echo "=== Coverage Summary ==="
        go tool cover -func=coverage.out | tail -1

  vulncheck:
    desc: "Run Go vulnerability check with govulncheck"
    summary: |
      Scans Go dependencies for known vulnerabilities using Google's govulncheck.
      This is more accurate than general scanners as it analyzes the call graph.
    cmds:
      - |
        set -euo pipefail
        echo "Running govulncheck on {{.src_dir}}"
        docker run --rm -v "$(pwd)/{{.src_dir}}:/workspace" -w /workspace {{.golang_image}} bash -c '
          set -euo pipefail
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck ./...
        '

  sbom:
    desc: "Generate Software Bill of Materials (SBOM) using Syft"
    summary: |
      Creates an SBOM in CycloneDX JSON format for the Go module.
      The SBOM catalogs all dependencies and can be used for compliance, auditing, and vulnerability scanning.
    cmds:
      - echo "Generating SBOM for {{.src_dir}} using Syft..."
      - mkdir -p sbom
      - |
        docker run --rm -v "$(pwd):/workspace" -w /workspace {{.syft_image}} \
          dir:{{.src_dir}} \
          -o cyclonedx-json=sbom/sbom.cdx.json \
          -o spdx-json=sbom/sbom.spdx.json \
          -o syft-json=sbom/sbom.syft.json
      - echo "SBOMs generated in sbom/ directory"

  sbom-scan:
    desc: "Scan SBOM for vulnerabilities using Grype"
    summary: |
      Scans the generated SBOM for known vulnerabilities using Anchore's Grype scanner.
      Run 'task sbom' first to generate the SBOM.
    deps:
      - sbom
    cmds:
      - echo "Scanning SBOM for vulnerabilities using Grype..."
      - |
        docker run --rm -v "$(pwd):/workspace" -w /workspace {{.grype_image}} \
          sbom:sbom/sbom.syft.json \
          --fail-on high \
          --only-fixed
      - echo "Vulnerability scan complete"

  grype:
    desc: "Scan the codebase directly for vulnerabilities using Grype"
    summary: |
      Scans the Go module directly for vulnerabilities without generating an SBOM first.
      Faster for quick checks, but sbom-scan is recommended for CI/audit trails.
    cmds:
      - echo "Scanning {{.src_dir}} for vulnerabilities using Grype..."
      - |
        docker run --rm -v "$(pwd):/workspace" -w /workspace {{.grype_image}} \
          dir:{{.src_dir}} \
          --fail-on high \
          --only-fixed
      - echo "Vulnerability scan complete"

  grype-image:
    desc: "Scan a Docker image for vulnerabilities using Grype"
    summary: |
      Scans a Docker image for vulnerabilities. Pass IMAGE=<image:tag> when invoking.
      Example: task grype-image IMAGE=myapp:latest
    cmds:
      - |
        if [ -z "${IMAGE:-}" ]; then
          echo "IMAGE must be set. Example: task grype-image IMAGE=myapp:latest" >&2
          exit 1
        fi
      - echo "Scanning Docker image ${IMAGE} for vulnerabilities..."
      - |
        docker run --rm \
          -v /var/run/docker.sock:/var/run/docker.sock \
          -v "$(pwd):/workspace" -w /workspace \
          {{.grype_image}} \
          docker:${IMAGE} \
          --fail-on high \
          --only-fixed
      - echo "Image vulnerability scan complete"

  trufflehog:
    desc: "Scan for secrets in the repository using Trufflehog"
    summary: |
      Scans the git repository history for accidentally committed secrets like API keys, passwords, and tokens.
      Uses the .trufflehog-exclude file to exclude example files and known false positives.
    cmds:
      - echo "Scanning repository for secrets using Trufflehog..."
      - |
        docker run --rm \
          -v "$(pwd):/workspace" -w /workspace \
          {{.trufflehog_image}} \
          git file:///workspace \
          --exclude-paths=/workspace/.trufflehog-exclude \
          --only-verified \
          --fail
      - echo "Secret scan complete - no verified secrets found"

  trufflehog-all:
    desc: "Scan for all potential secrets (including unverified) using Trufflehog"
    summary: |
      Scans for all potential secrets including unverified ones.
      This may produce more false positives but catches more potential issues.
    cmds:
      - echo "Scanning repository for all potential secrets using Trufflehog..."
      - |
        docker run --rm \
          -v "$(pwd):/workspace" -w /workspace \
          {{.trufflehog_image}} \
          git file:///workspace \
          --exclude-paths=/workspace/.trufflehog-exclude
      - echo "Secret scan complete"

  hadolint:
    desc: "Lint Dockerfiles using Hadolint"
    summary: |
      Validates Dockerfiles against best practices using Hadolint.
      Checks for common issues like missing version pinning, inefficient layers, and security concerns.
    cmds:
      - echo "Linting Dockerfiles with Hadolint..."
      - |
        docker run --rm -i \
          -v "$(pwd):/workspace" -w /workspace \
          {{.hadolint_image}} \
          hadolint \
          infra/build/dockerfiles/Dockerfile \
          infra/build/dockerfiles/Dockerfile.debug \
          infra/build/dockerfiles/oapi-codegen.Dockerfile
      - echo "Dockerfile linting complete"

  actionlint:
    desc: "Lint GitHub Actions workflows using actionlint"
    summary: |
      Validates GitHub Actions workflow files for syntax errors, type mismatches,
      deprecated features, and other common issues.
    cmds:
      - echo "Linting GitHub Actions workflows with actionlint..."
      - |
        docker run --rm \
          -v "$(pwd):/workspace" -w /workspace \
          {{.actionlint_image}} \
          -color
      - echo "GitHub Actions linting complete"

  gosec:
    desc: "Run Go security scanner (gosec)"
    summary: |
      Scans Go source code for security vulnerabilities using gosec.
      Detects issues like SQL injection, hardcoded credentials, weak crypto, and more.
    cmds:
      - echo "Running gosec security scan on {{.src_dir}}..."
      - |
        docker run --rm \
          -v "$(pwd):/workspace" -w /workspace/{{.src_dir}} \
          {{.gosec_image}} \
          -exclude-generated \
          -severity medium \
          -confidence medium \
          ./...
      - echo "Go security scan complete"

  lint-all:
    desc: "Run all linters (Go, API, AsyncAPI, Proto, Dockerfiles, Actions)"
    summary: |
      Runs all available linters in sequence: golangci-lint, Redocly, AsyncAPI, buf, Hadolint, and actionlint.
    deps:
      - lint-go
      - lint-api
      - lint-asyncapi
      - lint-proto
      - hadolint
      - actionlint

  security-all:
    desc: "Run all security scans (Trivy, gosec, Trufflehog, vulncheck)"
    summary: |
      Runs all security scanning tools: Trivy, gosec, Trufflehog, and govulncheck.
    deps:
      - scan-security
      - gosec
      - trufflehog
      - vulncheck

  act-test:
    desc: "Run a specific GitHub Actions job via act"
    summary: |
      Executes a single workflow job locally. Pass JOB=<name> when invoking.
    cmds:
      - echo "Running GitHub Action job '${JOB}' locally"
      - act --job ${JOB} | grep -v '::'

  lint-go:
    desc: "Lint the Go sources with golangci-lint"
    deps:
      - gen-buf
    summary: |
      Builds a Go {{.src_dir}} workspace inside a Go 1.25.4 container, installs golangci-lint v2.6.2 with the same toolchain, and executes the linter so the binary matches the module's target version.
    cmds:
      - |
        set -euo pipefail
        echo "Linting Go sources under {{.src_dir}} with Go 1.25.4"
        docker run --rm -v "$(pwd)/{{.src_dir}}:/workspace" -w /workspace {{.golang_image}} bash -c '
          set -euo pipefail
          export PATH=$PATH:/usr/local/go/bin
          mkdir -p /tmp/bin
          GOBIN=/tmp/bin go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2.6.2
          export PATH="/tmp/bin:$PATH"
          golangci-lint run ./...
        '

  build-go:
    desc: "Build the Go module"
    deps:
      - gen-buf
    summary: |
      Regenerates protobuf bindings and compiles the Go module to ensure local builds match CI expectations.
    cmds:
      - |
        set -euo pipefail
        echo "Building Go module under {{.src_dir}}"
        cd ./{{.src_dir}}
        go build ./...

  lint-api:
    desc: "Lint the OpenAPI definition with Redocly"
    deps:
      - gen-schema-index
    summary: |
      Ensures the API contract at api/api.yml is valid and consistent using the redocly.yaml configuration.
    cmds:
      - echo "Linting OpenAPI specification"
      - docker run --rm -v ./api/:/spec {{.redocly_cli_image}} lint api.yml --config redocly.yaml

  lint-proto:
    desc: "Lint protobuf specs with buf"
    summary: |
      Validates the protobuf definitions in {{.proto_dir}} using buf lint.
    cmds:
      - echo "Linting protobuf specifications"
      - docker run --rm -v "$(pwd)/{{.proto_dir}}:/workspace" -w /workspace {{.buf_image}} lint

  lint-asyncapi:
    desc: "Lint and validate the AsyncAPI specification"
    summary: |
      Bundles the multi-file AsyncAPI spec (resolving all $ref references), then validates
      the bundled result for correctness and best practices.
    cmds:
      - echo "Bundling AsyncAPI specification for validation"
      - mkdir -p async-api/bundle
      - docker run --rm -v "$(pwd)/async-api:/app" {{.asyncapi_cli_image}} bundle /app/asyncapi.yml -o /app/bundle/asyncapi.bundled.yml
      - echo "Validating bundled AsyncAPI specification"
      - docker run --rm -v "$(pwd)/async-api:/app" {{.asyncapi_cli_image}} validate /app/bundle/asyncapi.bundled.yml
      - echo "AsyncAPI specification is valid"

  bundle-asyncapi:
    desc: "Bundle AsyncAPI spec into JSON for serving via API"
    summary: |
      Bundles the multi-file AsyncAPI spec (resolving all $ref references) into a single JSON file
      for embedding in the apihandler package.
    cmds:
      - echo "Bundling AsyncAPI specification to JSON"
      - mkdir -p src/internal/server/handler/apihandler async-api/bundle
      - docker run --rm -v "$(pwd)/async-api:/app" {{.asyncapi_cli_image}} bundle /app/asyncapi.yml -o /app/bundle/asyncapi.bundled.yml
      - docker run --rm -v "$(pwd):/workspace" -w /workspace {{.yq_image}} -o=json ./async-api/bundle/asyncapi.bundled.yml > src/internal/server/handler/apihandler/asyncapi.json
      - echo "AsyncAPI JSON generated at src/internal/server/handler/apihandler/asyncapi.json"

  gen-asyncapi-models:
    desc: "Generate Go models from AsyncAPI message payloads (experimental)"
    summary: |
      Uses AsyncAPI Modelina to generate Go structs from the message schemas defined in the AsyncAPI spec.

      NOTE: This project uses protobuf for domain models (gen-buf), which is recommended.
      AsyncAPI models are generated for reference/comparison but the canonical types
      should come from proto/domain/v1. Use this task only if you need standalone
      event models without protobuf.
    cmds:
      - echo "Generating Go models from AsyncAPI specification"
      - mkdir -p src/internal/events/models
      - |
        npx -y @asyncapi/modelina-cli generate golang ./async-api/asyncapi.yml \
          --output src/internal/events/models \
          --packageName models \
          --goIncludeComments \
          --goIncludeTags
      - echo "Go models generated at src/internal/events/models"
      - echo "NOTE - Consider using protobuf-generated models from src/internal/domain instead"

  gen-asyncapi:
    desc: "Lint and bundle AsyncAPI spec (uses protobuf for models)"
    summary: |
      Validates the AsyncAPI spec and bundles to JSON for serving via /info/asyncapi.json.

      This project uses protobuf (gen-buf) for domain models rather than AsyncAPI codegen.
      The AsyncAPI spec serves as documentation for event contracts.
    deps:
      - lint-asyncapi
    cmds:
      - task: bundle-asyncapi
      - echo "AsyncAPI assets linted and bundled"

  gen-asyncapi-docs:
    desc: "Generate HTML documentation from AsyncAPI spec"
    summary: |
      Generates static HTML documentation from the AsyncAPI spec for viewing event contracts.
    cmds:
      - echo "Generating AsyncAPI documentation"
      - mkdir -p async-api/docs
      - docker run --rm -v "$(pwd)/async-api:/app" {{.asyncapi_cli_image}} generate fromTemplate /app/asyncapi.yml @asyncapi/html-template -o /app/docs
      - echo "Documentation generated at async-api/docs/index.html"

  build-oapi-codegen-image:
    desc: "Build the local oapi-codegen helper image"
    summary: |
      Produces the drblury/oapi-codegen image used for generating server interfaces.
    cmds:
      - docker build -t drblury/oapi-codegen -f infra/build/dockerfiles/oapi-codegen.Dockerfile infra/build/dockerfiles
    silent: true

  gen-api-std:
    desc: "Generate Go server interfaces from the OpenAPI spec"
    summary: |
      Bundles the OpenAPI spec with Redocly using the redocly.yaml config, runs oapi-codegen against the generated JSON, and removes intermediate artifacts.
    deps:
      - build-oapi-codegen-image
      - gen-schema-index
    cmds:
      - echo "Bundling OpenAPI spec and generating server interfaces"
      - mkdir -p src/internal/server/_gen
      - docker run --rm -v "$(pwd):/workspace" -w /workspace/api {{.redocly_cli_image}} bundle api.yml --config redocly.yaml --output /workspace/src/internal/server/_gen/openapi.json --ext json
      - docker run --rm -v "$(pwd):/workspace" -w /workspace/src drblury/oapi-codegen -config ../server-std.cfg.yml ./internal/server/_gen/openapi.json
      - rm src/internal/server/_gen/openapi.json
      - echo "Server interfaces generated under src/internal/server/gen"
    silent: true

  gen-api:
    desc: "Lint and regenerate the OpenAPI-driven server bindings"
    summary: |
      Runs the OpenAPI linter followed by oapi-codegen to refresh server stubs.
    deps:
      - lint-api
      - gen-api-std
    cmds:
      - echo "OpenAPI assets linted and regenerated"
    silent: true

  gen-schema-index:
    desc: "Regenerate the schema index from the existing fragments"
    summary: |
      Walks api/schemas/** and rewrites _index.yml so every reference matches an actual schema file before linting or codegen.
    cmds:
      - go run ./scripts/update-schema-index.go

  gen-buf:
    desc: "Generate Go code from protobuf definitions"
    summary: |
      Runs buf generate inside the official container, writing Go sources straight into src/internal/domain.
    cmds:
      - echo "Ensuring protobuf output directory exists"
      - mkdir -p ./src/internal/domain
      - echo "Generating protobuf code with buf"
      - docker run --rm -u "$(id -u):$(id -g)" -e BUF_CACHE_DIR=/tmp/buf-cache -v "$(pwd):/workspace" -w /workspace/proto {{.buf_image}} generate
      - echo "Protobuf code generated under ./src/internal/domain"
    silent: true

  gen-all:
    desc: "Regenerate all code from specs (protobuf, OpenAPI, AsyncAPI)"
    summary: |
      Complete code generation workflow that regenerates:
      - Protobuf Go bindings from proto/ definitions
      - HTTP server interfaces from OpenAPI spec
      - Event models from AsyncAPI spec
      Run this after modifying any API or event contract.
    deps:
      - gen-buf
      - gen-api
      - gen-asyncapi
    cmds:
      - echo "All code generation complete"

  scc:
    desc: "Show source code statistics using scc"
    summary: |
      Provides a language-level breakdown of the repository.
    cmds:
      - echo "Gathering source code statistics"
      - docker run --rm -it -v "$PWD:/pwd" {{.scc_image}} scc /pwd

  scc-files:
    desc: "Show per-file complexity stats using scc"
    summary: |
      Highlights the most complex files so you can focus refactoring where it matters.
    cmds:
      - echo "Gathering per-file complexity statistics"
      - docker run --rm -it -v "$PWD:/pwd" {{.scc_image}} scc --by-file --sort complexity /pwd

  git:web:
    desc: "Open the configured git remote in a browser"
    summary: |
      Invokes scripts/git-web with the provided REMOTE (defaults to origin).
    cmds:
      - ./scripts/git-web {{default "origin" .REMOTE}}
    silent: true

  debug:
    desc: "Start the app in debug mode with hot-reload (default) and the selected system backend"
    summary: |
      Reads SYSTEM from your environment and boots the matching docker-compose stack layered with the debug configuration.
      Hot-reload is enabled by default. Set HOT_RELOAD=false to disable it and use debugger-only mode.
    cmds:
      - |
        if [ -z "${SYSTEM:-}" ]; then
          echo "SYSTEM must be set to 'kafka', 'rabbitmq', 'aws', 'nats', 'http', or 'io'" >&2
          exit 1
        fi
      - task: compose-up
        vars:
          SYSTEM: "${SYSTEM}"
          DEBUG: true

  dev:
    desc: "Start the app with hot-reload using the selected system backend (alias for debug with HOT_RELOAD=true)"
    summary: |
      Convenience task that starts the app with hot-reload enabled.
      Usage: SYSTEM=kafka task dev
    cmds:
      - |
        if [ -z "${SYSTEM:-}" ]; then
          echo "SYSTEM must be set to 'kafka', 'rabbitmq', 'aws', 'nats', 'http', or 'io'" >&2
          exit 1
        fi
      - task: compose-up
        vars:
          SYSTEM: "${SYSTEM}"
          DEBUG: true
    env:
      HOT_RELOAD: "true"

  dev-no-reload:
    desc: "Start the app without hot-reload (debugger-only mode) using the selected system backend"
    summary: |
      Starts the app with hot-reload disabled, running the debugger directly.
      Useful when you need to set breakpoints without Air restarting the process.
      Usage: SYSTEM=kafka task dev-no-reload
    cmds:
      - |
        if [ -z "${SYSTEM:-}" ]; then
          echo "SYSTEM must be set to 'kafka', 'rabbitmq', 'aws', 'nats', 'http', or 'io'" >&2
          exit 1
        fi
      - task: compose-up
        vars:
          SYSTEM: "${SYSTEM}"
          DEBUG: true
    env:
      HOT_RELOAD: "false"

  compose-up:
    internal: true
    cmds:
      - echo "Starting {{.SYSTEM}} stack{{if .DEBUG}} in debug mode{{end}}"
      - docker compose -f {{.compose_base_file}} -f infra/compose/docker-compose.{{.SYSTEM}}.yml {{if .DEBUG}}-f {{.compose_debug_file}}{{end}} up --build
    env:
      UID:
        sh: id -u
      GID:
        sh: id -g

  compose-down:
    internal: true
    cmds:
      - echo "Stopping {{.SYSTEM}} stack"
      - docker compose -f {{.compose_base_file}} -f infra/compose/docker-compose.{{.SYSTEM}}.yml down

  up-rabbitmq:
    desc: "Start the RabbitMQ docker-compose stack"
    summary: |
      Boots the core services plus the RabbitMQ dependencies.
    cmds:
      - task: compose-up
        vars: { SYSTEM: rabbitmq }

  down-rabbitmq:
    desc: "Stop and remove the RabbitMQ stack"
    summary: |
      Tears down containers started by up-rabbitmq.
    cmds:
      - task: compose-down
        vars: { SYSTEM: rabbitmq }

  up-kafka:
    desc: "Start the Kafka docker-compose stack"
    summary: |
      Boots the core services plus Kafka and Kafdrop.
    cmds:
      - task: compose-up
        vars: { SYSTEM: kafka }

  down-kafka:
    desc: "Stop and remove the Kafka stack"
    summary: |
      Tears down containers started by up-kafka.
    cmds:
      - task: compose-down
        vars: { SYSTEM: kafka }

  up-aws:
    desc: "Start the AWS/localstack docker-compose stack"
    summary: |
      Boots the core services plus LocalStack and OpenObserve.
    cmds:
      - task: compose-up
        vars: { SYSTEM: aws }

  down-aws:
    desc: "Stop and remove the AWS/localstack stack"
    summary: |
      Tears down containers started by up-aws.
    cmds:
      - task: compose-down
        vars: { SYSTEM: aws }

  up-nats:
    desc: "Start the NATS docker-compose stack"
    summary: |
      Boots the core services plus NATS.
    cmds:
      - task: compose-up
        vars: { SYSTEM: nats }

  down-nats:
    desc: "Stop and remove the NATS stack"
    summary: |
      Tears down containers started by up-nats.
    cmds:
      - task: compose-down
        vars: { SYSTEM: nats }

  up-http:
    desc: "Start the HTTP docker-compose stack"
    summary: |
      Boots the core services configured for HTTP transport.
    cmds:
      - task: compose-up
        vars: { SYSTEM: http }

  down-http:
    desc: "Stop and remove the HTTP stack"
    summary: |
      Tears down containers started by up-http.
    cmds:
      - task: compose-down
        vars: { SYSTEM: http }

  up-io:
    desc: "Start the IO docker-compose stack"
    summary: |
      Boots the core services configured for IO (file) transport.
    cmds:
      - task: compose-up
        vars: { SYSTEM: io }

  down-io:
    desc: "Stop and remove the IO stack"
    summary: |
      Tears down containers started by up-io.
    cmds:
      - task: compose-down
        vars: { SYSTEM: io }
